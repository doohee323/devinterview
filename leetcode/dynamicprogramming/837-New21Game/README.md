# Problem
Leetcode : [here](https://leetcode.com/problems/new-21-game/)

[21 Card game](https://en.wikipedia.org/wiki/Twenty-One_(card_game))는 블랙잭의 조상인 카드게임이다. 이 문제는 새로운 룰을 제시하고 있다. Alice가 0에서 시작한다. Alice의 점수가 K보다 작으면 새 번호를 뽑는다. 새 번호는 1에서 정수 W까지 범위 안에서 임의의 정수로 정해진다. 각 뽑기는 독립적이며 모든 숫자는 동일한 확률로 뽑아진다. Alice가 K보다 같거나 큰 점수를 가지면 뽑기를 범춘다. Alice가 N과 같거나 작은 숫자를 뽑을 확율은? (즉, 블랙잭의 21과 같은게 N이고, 추가된 룰은 K이다. 블랙잭처럼 원하는 시점에 멈추는게 아니라 K보다 크거나 같면 멈춘다. 근데 그 값이 N보다 같거나 작으면 승리. 이 문제는 K보다 크거나 같은 값이 되었을 때, N보다 작은 확률을 구하는 문제다.)

> 예제1:
```
  Input: N = 10, K = 1, W = 10
  Output: 1.00000
  Explanation: K가 1이고 뽑기 숫자 범위는 1~10 이기 때문에 아무 숫자나 한번 뽑아도 게임은 멈춘다. N이 10이기 때문에 무조건 Alice의 점수는 N보다 같거나 작다. 그러므로 1.00000 이 결과.
```
> 예제 2:
```
  Input: N = 6, K = 1, W = 10
  Output: 0.60000
  Explanation: 예제 1과 같이 한번만 뽑으면 게임은 끝난다. N이 6이므로, 1~10 범위 숫자 중에 6보다 같거나 작은 숫자가 나올 확률은 60%이다.
```
> 예제3:
```
  Input: N = 21, K = 17, W = 10
  Output: 0.73278
```
> Note:
```
  1. 0 <= K <= N <= 10000
  2. 1 <= W <= 10000
  3. 답은 10^-5 까지
```

# Idea
예제3을 기준으로 고민해보자.
```
  N = 21, K = 17, W = 10

  K와 N 사이 값은 17, 18, 19, 20, 21 이다. 따라서 이 값들이 나올 확률의 합이 게임에서 승리할 확률이다. 각 숫자가 나올 확률은 해당 숫자의 이전 숫자가 나올 확률에 의존적이다. 예를 들면 21이 되려면 11 ~ 20 까지 숫자, 17은 7 ~ 16이다. 즉, n은 n-10 ~ n-1.

  이렇게..
  Win   [17, 18, 19, 20, 21]
  Win-1 [7, 8, 9, 10, 11, 12, 13,14, 15, 16, 17, 18, 19, 20]
  Win-2 [1~19]
  Win-3 [1~18]
  ...   [0]
    
  이런 식.. f(x) = (f(x-1) + ... + f(x-W)) / W
  
  이게 되려면 이전 숫자의 확률은 구해야한다. 그러니 1부터 가보자. 1이 맨 처음인데, 1은 1/W 확률로 나온다. W가 10이므로 1/10, 즉 0.1이다. 2는 2가 나오는 경우, 1다음에 1이 나오는 경우가 있다. 그러므로 (1.0 + 0.1) / W 이다. 3은 (1.0 + 0.1 + 0.11) / 10 이다. W가 10이므로 최대 이전 10개 숫자의 확률을 더해서 10으로 나눠주면 된다. 이전 숫자의 확률은 저장해두고 다시 쓰면된다(DP방식?). 그렇게 N까지 계산하면된다.
```

# Implementation
```golang
func new21Game(N int, K int, W int) float64 {
    // K가 0이거나 무슨 값을 뽑아도 N보다 같거나 작다면 100% 확률
    if K == 0 || K + W <= N {
        return 1.0
    }

    // N까지 숫자의 확률을 저장할 배열을 만든다. 코딩하기 편하게 인덱스 = 숫자
    dp := make([]float64, N+1)
    // K가 1이상이면 첫번째 뽑기는 100% 하는거니 0번째 인덱스에 1.0을 넣어둔다.
    dp[0] = 1.0

    // 이전 W개 숫자의 확률을 누적할 변수
    p := dp[0]

    // N까지 확률 계산 시작 :)
    for i := 1; i < N+1; i++ {
        // 숫자 i의 확률은 이전 W개 숫자의 확률을 모두 더해서 W로 나눈 값
        dp[i] = p / float64(W)
        // i가 K보다 작다면 다음 숫자 확률에 구할 때 써야하니까 더한다. K보다 같거나 크면 거기서 게임이 끝나니까 더 이상 계산할 필요가 없다. 예를 들면, i가 K일 때는 K+1을 구할 때 확률이 더해지면 안되니 p에 반영하면 안된다.
        if i < K {
            p += dp[i]
        }

        // i + 1의 확률을 구하기 위해 i - W 값은 빼준다. 최대 W개 숫자만 반영되어야 하니까
        if i - W >= 0 {
            p -= dp[i - W]
        }
    }

    // K보다 같거나 크고 N보다 같거나 작은 수의 확률을 다 더해주면 끝
    sum := 0.0
    for i := K; K < len(dp); i++ {
        sum += dp[i]
    }

    return sum
}

```