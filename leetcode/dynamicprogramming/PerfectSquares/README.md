# Problem
Leetcode : [here](https://leetcode.com/problems/perfect-squares/)

[완전제곱수(perfect square number)](https://ko.wikipedia.org/wiki/%EC%A0%95%EC%82%AC%EA%B0%81%EC%88%98)를 더해서 주어진 양의 정수 n을 만들려고 한다. 양수 n을 만들 수 있는 가장 적은 완전제곱수의 갯수는 몇개인가.

> 예제1:
```
  입력: n = 12
  결과: 3
  설명: 12 = 4 + 4 + 4
```
> 예제2:
```
  입력: n = 13
  결과: 2
  설명: 13 = 4 + 9
```

# Idea
DP의 접근방식인 '계산했던 이전 값을 저장해놓고 다시 쓰자.' 로 고민해보자. 이 문제의 경우 '계산했던 이전 값'은 아래와 같다.

- 계산했던 이전 값 = 'n에서 임의의 완전제곱수를 뺀 수'를 만들 수 있는 가장 적은 완전제곱수의 갯수

즉, n의 결과는 n보다 작은 수 중에 완전제곱수를 더해서 n이 될 수 있는 숫자 중에 하나. 12를 예로 들면 12의 경우 8 + 4 를 더해서 12를 만들 수 있는데, 8을 만들 수 있는 가장 적은 완전제곱수의 개수(=2) + 1이다.

그러면 8의 결과값을 먼저 구해서 가지고 있으면 된다. 그런데 8은 4의 결과값 + 1 이기 때문에 4의 결과값이 필요하다. 4를 완전제곱수로 만들 수 있는 방법은 두 가지 조합 1 + 1 + 1 + 1 와 4 뿐이다. 그러므로 4는 4 한개로 만들 수 있기 때문에 가장 적은 완전제곱수의 개수는 1이다. 그러므로 8은 2, 12는 3이 된다.

# Implementation
12의 결과값이 3이라는 것을 알기 때문에 위에서는 바로 구했지만 실제로 계산 중에는 8의 결과값 + 1이 최저값인지 모르기 때문에 12가 될 수 있는 모든 경우와 비교해야 한다.

그러므로 1부터 n까지 다 구하면 된다. 일단 숫자 i의 최악의 경우는 1+1..+1인 경우니까 i니까 그걸로 초기화 한다.
```golang
    dp := make([]int, n + 1)
    for i := 1; i <= n; i++ {
        dp[i] = i
    }
```
i 이전 값 중에 완전제곱수 x를 더해서 i가 가능한 수(= i - x)의 결과값과 현재 i의 결과값을 비교해서 최저값으로 선택하면 된다. 

- i보다 작은 수를 제곱해서 i보다 작으면 x다. 아래 코드에 j * j

그러면 최종 코드는 아래처럼 될 수 있다.

```golang
func numSquares(n int) int {
    dp := make([]int, n + 1)
    for i := 1; i <= n; i++ {
        dp[i] = i
        for j := 1; j * j <= i; j++ {
            dp[i] = min(dp[i], 1 + dp[i - j * j])
        }
    }
    return dp[n]
}

func min(a, b int) int {
    if a < b { return a }
    return b
}
```